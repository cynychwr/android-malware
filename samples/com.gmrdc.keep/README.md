

# **Application Details**

#### **Metadata**
> **Application Name:** Google Play    
> **Package:** com.gmrdc.keep     
> **Version Name:** 1.0.2    
> **Version Code:** 1    
> **Min. SDK Version:** 19    
> **Target SDK Version:** 29    
> **Hash:** 0ea5ad07e349e3fa5abfe24f11d8e07281f0c43e185b345160db9bdd2cb047f2        

#### **URLs**
> **Virus Total:** https://www.virustotal.com/gui/file/0ea5ad07e349e3fa5abfe24f11d8e07281f0c43e185b345160db9bdd2cb047f2    
> **Source:** http://jdfhgjmdfmn.duckdns.org/Google%20Play.apk

## **Classifications**
Based on the evidence provided on the **Analysis** section the following classifications could be attributed to this application:

- `Backdoor`
- `Spyware`
- `Trojan`

## **Description**

@TODO

## **Architecture**
Application was built nativaly using `Java`, without the usage of a framework and it's main code can be found under the package `com.hz.keep` after decompiling it.

#### **Native Libraries**
It showed to be using two native libraries as well, which may or not appears during the analysis.

- `librska.so`
- `libdaemon_code.so`

# **Analysis**
This section contains a through analysis of the target application. A mixture of static and dynamic analysis techniques has been performed in order to investigate the application's behaviour and conclude whether the application is malicious and can be classified as malware.

## **Permissions and Capabilities**
On opening the file `AndroidManifest.xml` it showed to have being using multiple **dangerous permissions** permissions that would make it capable of performing `Spyware` behaviour as well possibilly `Worm`, `SMS Fraud` and `Spam`.

- `android.permission.READ_PHONE_STATE`
- `android.permission.READ_CONTACTS`
- `android.permission.CALL_PHONE`
- `android.permission.READ_SMS`
- `android.permission.RECEIVE_SMS`
- `android.permission.WRITE_SMS`
- `android.permission.SEND_SMS`
- `android.permission.GET_ACCOUNTS`

> **Permission's list and details:** https://developer.android.com/reference/android/Manifest.permission

#### **Access capabilities**
Based on the application's permissions below is the list of type of data the application is capable of accessing and retrieving.

- Device's phone number;
- Contacts;
- All SMS store in the device;
- Received SMS;
- Accounts from the Accounts Service;

#### **Actions capabilities**
Based on the application's permissions below is the list of actions the application is capable to perform.

- Perform calls;
- Write and send SMS;

## **Dynamic Analysis**
This section contains all the testing and evaluation of the application in run-time.

### **Application's behaviour**
On running the application some interesting behaviours could be identified. Just on opening the first screen, the application asks the user to set itself as the **default SMS app** which is a completely suspicious behaviour.

If set as **default SMS app** the application is just closed and the user don't have any other way to interact with the app (the application is continuously closed when open).

If not set as **default SMS app**, it starts requesting multiple dangerous permissions to the user and after the permissions are granted, it's closed and performs the same behaviour saw before (continuously closing when open).

Another interesing point is that, after opened for the first time, the application creates an unclosable notification, which means it started a foreground service and has code running even with the application closed.

<p align="center">
    <img src="./screenshots/dynamic/5.png" width="200" />
    <img src="./screenshots/dynamic/6.png" width="200" /> 
    <img src="./screenshots/dynamic/7.png" width="200" />
    <img src="./screenshots/dynamic/8.png" width="200" />
    <br/>
    <strong>Images 5.png, 6.png, 7.png and 8.png:</strong> Screenshots of the application in run-time.
</p>

### **Intercepted requests**
On intercepting the requests made by the application some suspicious requests were identified.

#### **Request to http://210302.top**
One of the first requests made by the application, having the host http://165.3.93.6:6666/ as response from the request.

<p align="center">
    <img src="./screenshots/dynamic/1.png" />
    <br/>
    <strong>Image 1.png:</strong> Request made to http://210302.top.
</p>

#### **Request to http://165.3.93.6:6666/**
After being received as response from another request, the host http://165.3.93.6:6666/ is accessed by the application. But different from the last one, this request showed to be used on a `websocket` connection.

<p align="center">
    <img src="./screenshots/dynamic/2.png" />
    <br/>
    <strong>Image 2.png:</strong> Request made to http://165.3.93.6:6666/.
</p>

### **Other observations**
On validating the files on the internal storage of the application, none interesing files could be identified, in the other hand, the shared preferences file from the application showed to have some interesting strings, including the host received from the first request 

<p align="center">
    <img src="./screenshots/dynamic/3.png"/>
    <br/>
    <img src="./screenshots/dynamic/4.png"/> 
    <br/>
    <strong>Images 3.png and 4.png:</strong> Application's internal storage and shared preferences file.
</p>

## **Static Analysis**
This section contains all the analysis performed on the application's files that could be retrieved from the APK file, including applications code, resources, assets and native libraries and etc.

### **MainActivity**
On checking the code of the first activity launched by the application, which is determinated by the usage of the action `android.intent.action.MAIN` and the category `android.intent.category.LAUNCHER`, the activity `com.hz.keep.MainActivity`, showed to be simple and don't do much more than what it was observated during the dynamic analysis.

<p align="center">
    <img src="./screenshots/static/9.png" />
    <br/>
    <strong>Image 9.png:</strong> Definition of the MainActivity on the AndroidManifest.xml.
</p>

It basically request the required permissions, close the application when they are granted and additionaly to it when the `android.permission.READ_CONTACTS` is granted the method `onRequestPermissionsResult` will instantiate an Intent with the string **¨sendcontact¨** and send it as a broadcast.

#### **com.hz.keep.MainActivity**

- [onCreate](/screenshots/static/10.png)
- [onActivityResult](/screenshots/static/11.png)
- [onRequestPermissionsResult](/screenshots/static/12.png)

### **Application Class**
The application showed to have an custom application class with name `com.hz.keep.MyApplication`, which is the **base class** of the application and the first code to be executed when running. 

<p align="center">
    <img src="./screenshots/static/13.png" />
    <br/>
    <strong>Image 13.png:</strong> Definition of the MyApplication on the AndroidManifest.xml.
</p>

The application class doesn't execute too much code, limiting itself to only startup the **Bugly CrashReport** library and execute `KeepAlive.init`.

<p align="center">
    <img src="./screenshots/static/14.png" />
    <br/>
    <strong>Image 14.png:</strong> com.hz.keep.MyApplication code.
</p>

### **KeepAlive**
This is the most important class of the application, being where the malicious code will be executed.

#### **com.hz.keep.KeepAlive**
- [init](/screenshots/static/15.png)
- [startKeepAlive](/screenshots/static/16.png)
- [buildNotification](/screenshots/static/17.png)
- [getData](/screenshots/static/25.png)
- [getDataBeiyong](/screenshots/static/26.png)
- [startSendLocal](/screenshots/static/21.png)
- [sendSms](/screenshots/static/22.png)

### **Helper**

#### **cn.rs.keepalive.Helper**
- [start](/screenshots/static/23.png)
- [initializeNativeWatcher](/screenshots/static/24.png)

### **WorkService**

#### **cn.rs.keepalive.service.WorkService**
- [a](/screenshots/static/)

### **Broadcast Receivers**
List of broadcast receivers defined by `com.hz.keep.KeepAlive` at the `startKeepAlive` method.

#### **com.hz.keep.SmsReceiver**
This broadcast receiver has the action `android.provider.Telephony.SMS_RECEIVED` attached, which means that all the new received SMS the device receives, this class will intercept them.

At intercepting a SMS, all the data from it is retrieved and used to create a new instance of `UserTable` which is then stored on a local database by `DatabaseBusiness.updateUser`.

If the shared preferences has the value **lanjie_sms** set to **TRUE** then the method `setAllMessageRead` is executed, setting all the SMS as readed.

- [com.hz.keep.SmsReceiver](/screenshots/static/18.png)

#### **com.hz.keep.KeepAlive.PerReceiver**
At receiving the action `android.permissions.send` it will log the message ¨权限发送握手包¨ which means ¨Permission to send handshake packet¨ and send a package to the websocket.

The message is compose with: **¨握手包&¨ + `Application's version` + `Device's phone number` + `Device's model` + `Network Connection Type (¨4g¨ or ¨wifi¨)` + `Device's unique id`**

- [com.hz.keep.KeepAlive.PerReceiver](/screenshots/static/19.png)

#### **com.hz.keep.KeepAlive.SendContactReceiver**
t receiving the action `sendcontact` it will send the command `6` to be executed by `com.hz.keep.KeepAlive.mHandler` with a delay of 60 seconds.

- [com.hz.keep.KeepAlive.SendContactReceiver](/screenshots/static/20.png)