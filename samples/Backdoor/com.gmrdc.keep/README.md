

# **Application Details**

#### **Metadata**
> **Application Name:** Google Play    
> **Package:** com.gmrdc.keep     
> **Version Name:** 1.0.2    
> **Version Code:** 1    
> **Min. SDK Version:** 19    
> **Target SDK Version:** 29    
> **Hash:** 0ea5ad07e349e3fa5abfe24f11d8e07281f0c43e185b345160db9bdd2cb047f2        

#### **URLs**
> **Virus Total:** https://www.virustotal.com/gui/file/0ea5ad07e349e3fa5abfe24f11d8e07281f0c43e185b345160db9bdd2cb047f2    
> **Source:** http://jdfhgjmdfmn.duckdns.org/Google%20Play.apk

## **Classifications**
Based on the evidence provided on the **Analysis** section the following classifications could be attributed to this application.

### **Primary Classification**
Since the application uses socket connection in order to exchange messages with the server and execute other malicious flows through commands, the application should be classified as `Backdoor`.

### **Others Classifications**
Along side the primary classification, other classifications can be applied based on secondary and tertiary behaviors:

#### `Spyware`
For the upload of contacts and sms from the device without disclosure.

#### `Trojan`
For the impersonation of the application **Google Play**.

#### `SMS Fraud`
For the abuse of the capability of sending SMS and being capable of sending SMS for premium numbers, since the phone numbers and content used to send SMS are received by the server.

#### `Worm`
For the abuse of the capability of sending SMS and being capable of replicate itself, by sending download links to anonymous phone numbers retrieved from different victims, since the phone numbers and content used to send SMS are received by the server.

#### `Spam` 
For the abuse of the capability of sending SMS and being capable of sending multiple SMS repetitively.

## **Description**

Application that impersonates the **Google Play** app and performs `Backdoor` behaviour and other multiple malicious behaviours.

After being executed by the first time, it requests the user to be defined as the **default SMS package** which allows the app to get access to all the SMS from the device without the need of dangerous permissions. In case it's not defined as it, multiple dangerous permissions are requested.

The application doesn´t have features that the user can use, it basically closes after having the required permissions to work, continuasly doing it if the user tries to open the app.

On having the permissios, the application performs some requests and configurations and creates a socket connection to change messages and receive commands from the server.

Through these commands the application uploads multiple personal data from the user, such as contacts and sms and use the device as a zombie machine to send SMS with contents and to numbers sent by the server.

## **Architecture**
Application was built nativaly using `Java`, without the usage of a framework and it's main code can be found under the package `com.hz.keep` after decompiling it.

#### **Native Libraries**
It showed to be using two native libraries as well, which may or not appears during the analysis.

- `librska.so`
- `libdaemon_code.so`

# **Analysis**
This section contains a through analysis of the target application. A mixture of static and dynamic analysis techniques has been performed in order to investigate the application's behaviour and conclude whether the application is malicious and can be classified as malware.

## **Permissions and Capabilities**
On opening the file `AndroidManifest.xml` it showed to have being using multiple **dangerous permissions** permissions that would make it capable of performing `Spyware` behaviour as well possibilly `Worm`, `SMS Fraud` and `Spam`.

- `android.permission.READ_PHONE_STATE`
- `android.permission.READ_CONTACTS`
- `android.permission.CALL_PHONE`
- `android.permission.READ_SMS`
- `android.permission.RECEIVE_SMS`
- `android.permission.WRITE_SMS`
- `android.permission.SEND_SMS`
- `android.permission.GET_ACCOUNTS`

> **Permission's list and details:** https://developer.android.com/reference/android/Manifest.permission

#### **Access capabilities**
Based on the application's permissions below is the list of type of data the application is capable of accessing and retrieving.

- Device's phone number;
- Contacts;
- All SMS store in the device;
- Received SMS;
- Accounts from the Accounts Service;

#### **Actions capabilities**
Based on the application's permissions below is the list of actions the application is capable to perform.

- Perform calls;
- Write and send SMS;

## **Dynamic Analysis**
This section contains all the testing and evaluation of the application in run-time.

### **Application's behaviour**
On running the application some interesting behaviours could be identified. Just on opening the first screen, the application asks the user to set itself as the **default SMS package** which is a completely suspicious behaviour.

If set as **default SMS package** the application is just closed and the user don't have any other way to interact with the app (the application is continuously closed when open).

If not set as **default SMS package**, it starts requesting multiple dangerous permissions to the user and after the permissions are granted, it's closed and performs the same behaviour saw before (continuously closing when open).

Another interesing point is that, after opened for the first time, the application creates an unclosable notification, which means it started a foreground service and has code running even with the application closed.

<p align="center">
    <img src="./screenshots/dynamic/5.png" width="200" />
    <img src="./screenshots/dynamic/6.png" width="200" /> 
    <img src="./screenshots/dynamic/7.png" width="200" />
    <img src="./screenshots/dynamic/8.png" width="200" />
    <br/>
    <strong>Images 5.png, 6.png, 7.png and 8.png:</strong> Screenshots of the application in run-time.
</p>

### **Intercepted requests**
On intercepting the requests made by the application some suspicious requests were identified.

#### **Request to http://210302.top**
One of the first requests made by the application, having the host http://165.3.93.6:6666/ as response from the request.

<p align="center">
    <img src="./screenshots/dynamic/1.png" />
    <br/>
    <strong>Image 1.png:</strong> Request made to http://210302.top.
</p>

#### **Request to http://165.3.93.6:6666/**
After being received as response from another request, the host http://165.3.93.6:6666/ is accessed by the application. But different from the last one, this request showed to be used on a `websocket` connection.

<p align="center">
    <img src="./screenshots/dynamic/2.png" />
    <br/>
    <strong>Image 2.png:</strong> Request made to http://165.3.93.6:6666/.
</p>

### **Other observations**
On validating the files on the internal storage of the application, none interesing files could be identified, in the other hand, the shared preferences file from the application showed to have some interesting strings, including the host received from the first request 

<p align="center">
    <img src="./screenshots/dynamic/3.png"/>
    <br/>
    <img src="./screenshots/dynamic/4.png"/> 
    <br/>
    <strong>Images 3.png and 4.png:</strong> Application's internal storage and shared preferences file.
</p>

## **Static Analysis**
This section contains all the analysis performed on the application's files that could be retrieved from the APK file, including applications code, resources, assets and native libraries and etc.

### **MainActivity**
On checking the code of the first activity launched by the application, which is determinated by the usage of the action `android.intent.action.MAIN` and the category `android.intent.category.LAUNCHER`, the activity `com.hz.keep.MainActivity`, showed to be simple and don't do much more than what it was observated during the dynamic analysis.

<p align="center">
    <img src="./screenshots/static/9.png" />
    <br/>
    <strong>Image 9.png:</strong> Definition of the MainActivity on the AndroidManifest.xml.
</p>

It basically request the required permissions, close the application when they are granted and additionaly to it when the `android.permission.READ_CONTACTS` is granted the method `onRequestPermissionsResult` will instantiate an Intent with the string **¨sendcontact¨** and send it as a broadcast.

#### **com.hz.keep.MainActivity**

- [onCreate](./screenshots/static/10.png)
- [onActivityResult](./screenshots/static/11.png)
- [onRequestPermissionsResult](./screenshots/static/12.png)

### **Application Class**
The application showed to have an custom application class with name `com.hz.keep.MyApplication`, which is the **base class** of the application and the first code to be executed when running. 

<p align="center">
    <img src="./screenshots/static/13.png" />
    <br/>
    <strong>Image 13.png:</strong> Definition of the MyApplication on the AndroidManifest.xml.
</p>

The application class doesn't execute too much code, limiting itself to only startup the **Bugly CrashReport** library and execute `KeepAlive.init`.

<p align="center">
    <img src="./screenshots/static/14.png" />
    <br/>
    <strong>Image 14.png:</strong> com.hz.keep.MyApplication code.
</p>

### **KeepAlive**
The class `com.hz.keep.KeepAlive` is the core class of the application, being where the malicious code is configurated and executed.

#### **Initialization and configuration**
As soon method `init` is called by the application class it will start configurating itself by calling `startKeepAlive`, which will then execute the method `initialize` from `cn.rs.keepalive.Helper`, passing the a **task** that is created and has the part of the configuration that's going to be made, the notification that's going to be executed with the foregound service and a integer value representing the **id** of the foreground service that will be executed. The configurations made by this mentioned task are the setup of the broadcast receivers, the call of `getData` and the call of `startSendLocal`.

#### **Requests of the websocket host**
The method `getData` called at the configuration phase is responsible for accessing and validating the existence of the value **sp_connect_url** from the shared preferences file which is the host of the websocket used by the application. Case the value is null or empty the method performs the first request to http://210302.top/ that was mentioned here at the *dynamic analysis section*.

On a sucessful request, the response data from the request is retrieved and saved at the shared preferences file adding the string **¨ws://¨** at the beggining and then sending a delayed empty message to `mHandler` with number **3** and and **1 second** of delay.

In case of failure and it wasn't possible to retrieve the host from the request, the method `getDataBeiyong` is executed, which will perform the exact same behaviour but trying to request to http://210302bei.top/.

#### **The Handler**
The variable `mHandler` is a **Handler** that's used multiple times by the code, in different moments and has multiple purposes. In total it can perform 7 different behaviours based on the value **what** from the received **message**, below you can find the list and details of these behaviours.

0. [**Alive validation:**](./screenshots/static/28.png) Recursive calls with 10 seconds of delay that sends a package through the websocket with the string "心跳&ping", in order to confirm that the system is alive.
1. [**Default SMS package validation:**](./screenshots/static/29.png) Recursive calls with 1 minute of delay that validates if the application is the default SMS package from tje device, case it's not, it will request to be set up as it, calling itself each minute until the user put the application as it.
2. [**Connection validation:**](./screenshots/static/30.png) Validates if the websocket is connected and if the host of the websocket was configurated.
3. [**WebSocket's configuration:**](./screenshots/static/31.png) Performs validations on regards to the websocket, configurates the client and executed the method `initWebSocketListener` which will configurate the websocket listener.
4. [**Send SMS:**](./screenshots/static/32.png) Executes the method `sendSms` passing the phone number and content from the lists `mMobiles` and `mContents` using the index `currentMobileIndex`.
5. [**Permissions validation:**](./screenshots/static/33.png) Validates if the required permissions were granted by the user, sending a package with the string ¨权限&未获取权限¨ through the websocket in case some permission wasn't granted.
6. [**Upload contacts:**](./screenshots/static/34.png) Sends a package through the websocket with the result from the method `getTxl`, which is responsible for collecting the name and phone number of all the device's contacts.

#### **WebSocket commands**
With the call of `initWebSocketListener`, the websocket listener is configurated, having the methods **onOpen**, **onMessage**, **onClosed**, **onClosing** and **onFailure** implemented.

At [**onOpen**](./screenshots/static/41.png) the variable `mIsConnected` is set up as **TRUE** a package is sent through the websocket containing (**Application's version** + **Device's phone number** + **Device's model** + **Network Connection Type** + **Device's unique id**) and the flows **6, 0, 1 and 5** from `mHandler` are executed.

At [**onFailure**](./screenshots/static/42.png) the variable `mIsConnected` is set up as **FALSE**, some validations are made and the flows **4, 2 and 1** from `mHandler` are executed.

Below is the list of commands defined at **onMessage** that the system is awaiting to receive as message from the server, with it's behaviours.
- [**通讯录:**](./screenshots/static/35.png) Same behaviour as the flow **6** from `mHandler`, uploads the contacts from the device.
- [**收件箱:**](./screenshots/static/36.png) Sends a package through the websocket with the result from the method `getLocalSms`, which is responsible for collecting the list of sms that was retrieved by `com.hz.keep.SmsReceiver` and stored in `com.hz.keep.db.DatabaseBusiness`.
- [**拦截短信&open:**](./screenshots/static/37.png) Define the boolean **¨lanjie_sms¨** from the shared preferences file as **TRUE** and sends a package through the websocket with the string **"拦截短信&open|true"**.
- [**拦截短信&close:**](./screenshots/static/38.png) Define the boolean **¨lanjie_sms¨** from the shared preferences file as **FALSE** and sends a package through the websocket with the string **"拦截短信&close|true"**.
- [**发信息&:**](./screenshots/static/39.png) Retrieves data from the received command package, populates the variables `mMobiles`, `mDaiMobiles`, `mContents`, `mDaiContents`, manipulate multiple values from the shared preferences file that referes to these data and execute the methods `saveLocal` and `sendSms`.
- [**下线&:**](./screenshots/static/40.png) Close the socket connection, set the socket variables as **null** and define the value **¨sp_offline¨** from the shared preferences file as **¨1¨**.

> #### **com.hz.keep.KeepAlive**
> - [init](./screenshots/static/15.png)
> - [startKeepAlive](./screenshots/static/16.png)
> - [buildNotification](./screenshots/static/17.png)
> - [getData](./screenshots/static/25.png)
> - [getDataBeiyong](./screenshots/static/26.png)
> - [getTxl](./screenshots/static/27.png)
> - [getLocalSms](./screenshots/static/43.png)
> - [saveLocal](./screenshots/static/44.png)
> - [startSendLocal](./screenshots/static/21.png)
> - [sendSms](./screenshots/static/22.png)

### **Helper**
Support class used by `com.hz.keep.KeepAlive` to configurate the malicious behaviour, the native libraries are loaded after the method `initializeNativeWatcher` is called.

> #### **cn.rs.keepalive.Helper**
> - [initialize](./screenshots/static/45.png)
> - [start](./screenshots/static/23.png)
> - [initializeNativeWatcher](./screenshots/static/24.png)

### **Broadcast Receivers**
List of broadcast receivers defined by `com.hz.keep.KeepAlive` at the `startKeepAlive` method.

#### **com.hz.keep.SmsReceiver**
This broadcast receiver has the action `android.provider.Telephony.SMS_RECEIVED` attached, which means that all the new received SMS the device receives, this class will intercept them.

At intercepting a SMS, all the data from it is retrieved and used to create a new instance of `UserTable` which is then stored on a local database by `DatabaseBusiness.updateUser`.

If the shared preferences has the value **lanjie_sms** set to **TRUE** then the method `setAllMessageRead` is executed, setting all the SMS as readed.

> - [com.hz.keep.SmsReceiver](./screenshots/static/18.png)

#### **com.hz.keep.KeepAlive.sendMessage**
Broadcast receiver that listen to the `SENT_SMS_ACTION` action and notifies the server about the success or failure on delivering the sms by sending a package through the websocket.

> - [com.hz.keep.KeepAlive.sendMessage](./screenshots/static/46.png)

#### **com.hz.keep.KeepAlive.PerReceiver**
At receiving the action `android.permissions.send` it will log the message ¨权限发送握手包¨ and send a package to the websocket containing (**Application's version** + **Device's phone number** + **Device's model** + **Network Connection Type** + **Device's unique id**)

> - [com.hz.keep.KeepAlive.PerReceiver](./screenshots/static/19.png)

#### **com.hz.keep.KeepAlive.SendContactReceiver**
At receiving the action `sendcontact` it will send the command `6` to be executed by `com.hz.keep.KeepAlive.mHandler` with a delay of 60 seconds.

> - [com.hz.keep.KeepAlive.SendContactReceiver](./screenshots/static/20.png)